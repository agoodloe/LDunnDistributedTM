\section{Background}
A distributed system is a collection of independent entities that
cooperate to solve a problem that cannot be individually solved
\cite{kshemkalyani_singhal_2008}. In this document, we consider
distributed airborne and ground-based agents that cooperate to solve
shared tasks such as navigating safely, delivering resources,
collecting and disseminating of data, and combating fires. From a
computing perspective, the system consists of these agents
communicating over a shared network, such as an ad-hoc mesh network.

A distributed computing system has been characterized as

\begin{quotation}
   A collection of computers that do not share common memory or a common
   physical clock, that communicate by a messages passing over a communication
   network, and where each computer has its own memory and runs its own
   operating system.
   \cite{10.5555/562065}
\end{quotation}


In the context of System Wide Safety (SWS), the independent entities can include ground-based emergency responders, RADAR stations, crewed and uncrewed aircraft, air traffic controllers, or other personnel. Shared tasks include navigating safely, delivering resources, surveying and collecting data, and combating fires.

Compared to a standalone computer, distributed computing systems introduce new
challenges in both theory and practice. For example, absence of a common memory requires communication by message-passing over some network; this network may be unreliable, particularly in the context of emergency response scenarios where high-bandwidth communication is not generally available to all clients. Unreliable network conditions can result in delayed or dropped messages, or messages that arrive in the wrong order. Such behavior complicates coordination and generally leads to degraded system performance. Another challenge considered in this memo involves fusing data produced by independent but potentially overlapping sources. This will typically involve some amount of estimation and probability, as some data may be unavailable (perhaps because network conditions temporarily prevent communication with the data source). Entities may also produce conflicting data which must be resolved in some probabilistic way. For example, systems may need to contend with conflicting reports about whether a structure is occupied, where a vehicle is located, or how quickly a fire is traveling.


To discuss these challenges and provide some hints for how they may be dealt with,
we now introduce some standard terminology. Hereafter, a \emph{system} is
always distributed. Individual participants in the system are its
\emph{nodes}---the set of nodes may change as the system evolves in time, for example if a new vehicle arrives on scene or a hardware failure occurs. A
\emph{correct} node is one whose hardware is functioning as designed and which
faithfully implements the protocol or coordination scheme under consideration.
Any other node is \emph{failing}---perhaps for innocent reasons like hardware
failure, or perhaps because the node is an adversary.\footnote{A certain class
of innocent failures, now termed \emph{Byzantine faults} and known to occur in
the wild, can exhibit behavior that looks like that of an intentionally
deceptive adversary. \cite{1979Sift}} System nodes typically receive and handle
requests from clients, often human users, often to read or write some value in a
shared database or to reserve some limited resource like a synchronization
primitive or airline ticket. Another kind of node might be one attached to
\emph{sensors}, such as a weather-monitoring satellite, in which case the goal
is often to integrate the global set of sensor data and distribute this data to
interested clients.

The basic challenge of distributed systems is to present the illusion that the system is not in fact distributed. That is, as far system clients can tell, the system nodes in fact share a common global memory and a common global understanding of the order of events, as if all system actions were executed by a single machine. For instance, a client who writes a value in one variable should be able to read back that same value on a different node. This behavior will of course require the mutual cooperation of the two nodes, which is facilitated by message-passing.
